<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mic Delay + Cat Audio Player</title>
<style>
  body {
    background: #111;
    color: white;
    font-family: Arial, sans-serif;
    text-align: center;
    padding: 2rem;
  }
  button {
    font-size: 1.2rem;
    padding: 0.6rem 1.2rem;
    margin-bottom: 1rem;
    cursor: pointer;
  }
  label {
    display: block;
    margin-top: 1rem;
  }
  input[type=range] {
    width: 80%;
    margin-top: 0.5rem;
  }
</style>
</head>
<body>

<h1>Mic Delay + Cat Audio Player</h1>

<button id="startBtn">Start</button>

<div>
  <label for="micVol">Mic Playback Volume</label>
  <input type="range" id="micVol" min="0" max="2" step="0.01" value="1" />
</div>
<div>
  <label for="catVol">Cat Audio Volume</label>
  <input type="range" id="catVol" min="0" max="2" step="0.01" value="1" />
</div>

<script>
(async () => {
  const startBtn = document.getElementById('startBtn');
  const micVolSlider = document.getElementById('micVol');
  const catVolSlider = document.getElementById('catVol');

  let audioCtx, micSource, delayNode, gainNodeMic, gainNodeCat;
  let micStream;
  let micPlaybackNode;
  let catAudio = new Audio();
  catAudio.loop = true;

  // Speech recognition setup (Chrome supports window.SpeechRecognition)
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert("Speech Recognition API not supported in this browser.");
    startBtn.disabled = true;
    return;
  }
  const recognizer = new SpeechRecognition();
  recognizer.lang = 'en-US';
  recognizer.continuous = true;
  recognizer.interimResults = false;

  // Variables to hold last recognized transcript
  let lastTranscript = '';

  // Audio nodes for mic
  function createAudioGraph(stream) {
    audioCtx = new AudioContext();

    micSource = audioCtx.createMediaStreamSource(stream);

    // Create delay node for 3 second delay
    delayNode = audioCtx.createDelay(5.0);
    delayNode.delayTime.value = 3.0;

    // Gain node for mic playback volume
    gainNodeMic = audioCtx.createGain();
    gainNodeMic.gain.value = micVolSlider.value;

    // Connect: mic source -> delay -> gain -> destination
    micSource.connect(delayNode);
    delayNode.connect(gainNodeMic);
    gainNodeMic.connect(audioCtx.destination);

    // Cat audio gain node
    gainNodeCat = audioCtx.createGain();
    gainNodeCat.gain.value = catVolSlider.value;

    // Connect cat audio element to audio context destination with gain
    const catAudioSource = audioCtx.createMediaElementSource(catAudio);
    catAudioSource.connect(gainNodeCat);
    gainNodeCat.connect(audioCtx.destination);
  }

  // Dynamic volume control for mic playback (amplify if low volume)
  let analyser, dataArray;
  function setupVolumeAnalyser() {
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    // Insert analyser between delay node and gainNodeMic
    delayNode.disconnect();
    delayNode.connect(analyser);
    analyser.connect(gainNodeMic);
  }

  function getAverageVolume() {
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      sum += dataArray[i];
    }
    return sum / dataArray.length / 255; // normalized 0-1
  }

  // Adjust mic gain dynamically based on volume
  function adjustMicVolume() {
    if (!gainNodeMic) return;
    let avgVol = getAverageVolume();
    // If very low volume (<0.05), amplify up to 2x
    if (avgVol < 0.05) {
      gainNodeMic.gain.value = Math.min(2, micVolSlider.value * 4);
    } else if (avgVol < 0.15) {
      gainNodeMic.gain.value = Math.min(2, micVolSlider.value * 2);
    } else {
      gainNodeMic.gain.value = micVolSlider.value;
    }
  }

  // Set volumes on slider input
  micVolSlider.oninput = () => {
    if (gainNodeMic) gainNodeMic.gain.value = micVolSlider.value;
  };
  catVolSlider.oninput = () => {
    if (gainNodeCat) gainNodeCat.gain.value = catVolSlider.value;
  };

  // Start speech recognition and audio processing
  startBtn.onclick = async () => {
    startBtn.disabled = true;
    // Get mic stream
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      alert('Error accessing microphone: ' + err.message);
      return;
    }

    createAudioGraph(micStream);
    setupVolumeAnalyser();

    // Start cat audio default with CAT1
    catAudio.src = 'CAT1.mp3';
    catAudio.play();

    // Start speech recognition
    recognizer.start();

    // Every 10 seconds, evaluate last transcript word count
    setInterval(() => {
      let transcript = lastTranscript.trim();
      let wordCount = transcript === '' ? 0 : transcript.split(/\s+/).length;

      let catToPlay;
      if (wordCount === 0) catToPlay = 'CAT1.mp3';
      else if (wordCount <= 3) catToPlay = 'CAT2.mp3';
      else catToPlay = 'CAT3.mp3';

      if (catAudio.src.indexOf(catToPlay) === -1) {
        // Replace cat audio source & restart
        catAudio.pause();
        catAudio.src = catToPlay;
        catAudio.currentTime = 0;
        catAudio.play();
      }

      // Reset lastTranscript for next period
      lastTranscript = '';
    }, 10000);

    // On speech recognition result, update transcript
    recognizer.onresult = (event) => {
      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          lastTranscript += event.results[i][0].transcript + ' ';
        }
      }
    };

    recognizer.onerror = (event) => {
      console.error('Speech recognition error:', event.error);
      // Restart recognizer if it stops
      if (event.error === 'no-speech' || event.error === 'network' || event.error === 'not-allowed') {
        recognizer.stop();
        setTimeout(() => recognizer.start(), 1000);
      }
    };

    // Continually adjust mic volume dynamically
    function volumeLoop() {
      adjustMicVolume();
      requestAnimationFrame(volumeLoop);
    }
    volumeLoop();
  };
})();
</script>

</body>
</html>

