<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mic Delay + Cat Audio Player</title>
<style>
  body { background: #111; color: #eee; font-family: sans-serif; padding: 1rem; }
  button { font-size: 1.2rem; padding: 0.5rem 1rem; margin-bottom: 1rem; cursor: pointer; }
  label { display: block; margin: 1rem 0 0.2rem; }
  input[type=range] { width: 100%; }
  #status { margin-top: 1rem; font-size: 1rem; }
</style>
</head>
<body>

<button id="startBtn">Start Mic & Audio</button>

<label for="micVol">Mic Playback Volume</label>
<input type="range" id="micVol" min="0" max="2" step="0.01" value="1" />

<label for="catVol">Background Cat Audio Volume</label>
<input type="range" id="catVol" min="0" max="1" step="0.01" value="0.5" />

<div id="status">Status: Waiting to start...</div>

<script>
(async () => {
  const startBtn = document.getElementById('startBtn');
  const micVolSlider = document.getElementById('micVol');
  const catVolSlider = document.getElementById('catVol');
  const statusDiv = document.getElementById('status');

  let audioCtx, micStream, micSource, micGainNode, delayNode, delayBuffer, delayWritePos = 0;
  let micOutputGainNode;
  let catAudio = new Audio();
  catAudio.loop = true;

  let dynamicMicGain = 1;
  let analyzingInterval;
  let speechRecognizer;
  let isRunning = false;

  // Constants
  const delaySeconds = 3;
  const sampleRate = 44100; // standard

  // Audio buffers for delay
  let delayBufferSize;

  // State
  let catPlaying = null;

  startBtn.onclick = startSystem;

  micVolSlider.oninput = () => {
    if (micOutputGainNode) micOutputGainNode.gain.setValueAtTime(micVolSlider.value, audioCtx.currentTime);
  };
  catVolSlider.oninput = () => {
    catAudio.volume = catVolSlider.value;
  };

  async function startSystem() {
    if (isRunning) return;
    isRunning = true;
    statusDiv.textContent = 'Status: Starting...';

    // Setup audio context
    audioCtx = new AudioContext();
    delayBufferSize = sampleRate * delaySeconds;

    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch(e) {
      statusDiv.textContent = 'Error: Cannot access mic.';
      console.error(e);
      return;
    }

    // Create source & nodes
    micSource = audioCtx.createMediaStreamSource(micStream);
    micGainNode = audioCtx.createGain(); // For dynamic mic gain boost
    micOutputGainNode = audioCtx.createGain(); // For user volume control

    // Delay buffer to simulate 3s delay manually with ScriptProcessorNode (deprecated but easier here)
    // We'll use AudioWorklet if we want modern approach, but for simplicity:
    // Using a ScriptProcessorNode:
    const bufferSize = 4096;
    const delayProcessor = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    delayBuffer = new Float32Array(delayBufferSize);
    delayWritePos = 0;

    micSource.connect(micGainNode);
    micGainNode.connect(delayProcessor);
    delayProcessor.connect(micOutputGainNode);
    micOutputGainNode.connect(audioCtx.destination);
    micOutputGainNode.gain.setValueAtTime(micVolSlider.value, audioCtx.currentTime);

    // Process audio for delay manually
    delayProcessor.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      for (let i = 0; i < input.length; i++) {
        // Write input to delayBuffer
        delayBuffer[delayWritePos] = input[i];
        delayWritePos = (delayWritePos + 1) % delayBufferSize;
      }

      // Calculate read position (3 seconds behind)
      let readPos = delayWritePos;
      // Output delayed sample
      for (let i = 0; i < output.length; i++) {
        output[i] = delayBuffer[readPos];
        readPos = (readPos + 1) % delayBufferSize;
      }

      // Calculate RMS volume for input buffer to adjust dynamic gain
      let rms = 0;
      for (let i = 0; i < input.length; i++) rms += input[i] * input[i];
      rms = Math.sqrt(rms / input.length);

      // Adjust dynamic gain: boost if rms < 0.02, max boost 6x (2.0)
      const targetGain = rms < 0.02 ? 2.0 : 1.0;
      // Smooth gain adjustment
      dynamicMicGain += (targetGain - dynamicMicGain) * 0.05;
      micGainNode.gain.setTargetAtTime(dynamicMicGain, audioCtx.currentTime, 0.1);
    };

    // Setup Speech Recognition every 10 seconds
    setupSpeechRecognition();

    statusDiv.textContent = 'Status: Running. Speak now.';
    startBtn.disabled = true;
  }

  function setupSpeechRecognition() {
    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
      statusDiv.textContent = 'Speech Recognition API not supported in this browser.';
      return;
    }

    // Use webkit prefix if available
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    speechRecognizer = new SpeechRecognition();

    speechRecognizer.continuous = false;
    speechRecognizer.interimResults = false;
    speechRecognizer.lang = 'en-US';

    // Run recognition every 10 seconds on micStream
    function recognizeSpeech() {
      if (!isRunning) return;

      speechRecognizer.start();

      speechRecognizer.onresult = (event) => {
        if (!event.results || event.results.length === 0) return;
        const transcript = event.results[0][0].transcript.trim();
        const wordCount = transcript === '' ? 0 : transcript.split(/\s+/).length;

        statusDiv.textContent = `Heard: "${transcript}" (${wordCount} words)`;

        // Decide cat audio to play
        let catFile = null;
        if (wordCount === 0) catFile = 'CAT1.mp3';
        else if (wordCount <= 3) catFile = 'CAT2.mp3';
        else catFile = 'CAT3.mp3';

        playCatAudio(catFile);
      };

      speechRecognizer.onerror = (e) => {
        console.log('Speech recognition error:', e.error);
        // If error, play CAT1
        playCatAudio('CAT1.mp3');
      };

      // Schedule next recognition after 10 seconds
      setTimeout(() => {
        if (speechRecognizer) speechRecognizer.stop();
        setTimeout(() => {
          recognizeSpeech();
        }, 100);
      }, 10000);
    }

    recognizeSpeech();
  }

  function playCatAudio(filename) {
    if (catPlaying === filename) return; // same audio, do nothing

    catAudio.src = filename;
    catAudio.volume = catVolSlider.value;
    catAudio.loop = true;
    catAudio.play().catch(e => {
      console.warn('Failed to play cat audio:', e);
    });
    catPlaying = filename;
  }
})();
</script>

</body>
</html>


