<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Soft Opposition Voice Reaction - Debug Improved</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    #log {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid gray;
      margin-top: 20px;
      padding: 10px;
      background: #111;
      text-align: left;
      font-size: 14px;
    }
  </style>
</head>
<body>

<h1>üé§ Soft Opposition Voice Reaction (Debug Improved)</h1>
<button id="startBtn">üéß D√©marrer</button>
<div id="status">Pr√™t.</div>
<div id="log"></div>

<script>
  const keywordMap = {
    "ok": ["M/a2.mp3"],
    "oui": ["M/a3.mp3"]
  };
  const fallbackClips = ["M/merci1.mp3", "M/merci2.mp3", "M/merci3.mp3"];
  let unusedFallbacks = [...fallbackClips];

  const recordStartSound = "click.mp3";
  const RECORD_DURATION = 2000;

  let audioCtx = null;
  let mediaRecorder = null;
  let recordedChunks = [];
  let userPitch = 200, userSpeed = 0.05, userVolume = 0.1;

  let lastRecognizedText = "";

  document.getElementById("startBtn").onclick = () => {
    startProcess();
  };

  // --- Added network status check ---
  function updateNetworkStatus() {
    const online = navigator.onLine;
    logLine(online ? "üåê Connect√© √† Internet" : "‚ùå Pas de connexion Internet");
    updateStatus(online ? "üåê En ligne" : "‚ùå Hors ligne");
  }
  window.addEventListener('online', updateNetworkStatus);
  window.addEventListener('offline', updateNetworkStatus);
  updateNetworkStatus();
  // --- End network status check ---

  async function startProcess() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') await audioCtx.resume();

      recordedChunks = [];
      lastRecognizedText = "";

      updateStatus("üîä Jouer son de d√©marrage...");
      await playStartSound();

      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      updateStatus("üéôÔ∏è Micro activ√©, d√©marrage enregistrement...");

      startRecognition();

      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => {
        recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = () => {
        // If recognition already gave a result and played audio, do nothing here.
        // If no recognized text, fallback after recording:
        if (!lastRecognizedText) {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          analyzeAndPlay(blob);
        }
      };

      mediaRecorder.start();
      updateStatus("üéôÔ∏è Enregistrement en cours...");

      // Safety timeout to stop recording after RECORD_DURATION
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }
      }, RECORD_DURATION);
    } catch (err) {
      console.error("Erreur d√©marrage processus:", err);
      updateStatus("‚ùå Erreur : " + err.message);
      logLine("‚ùå " + err.message);
    }
  }

  function updateStatus(text) {
    document.getElementById("status").textContent = text;
    console.log("Status:", text);
  }

  function playStartSound() {
    return new Promise((resolve) => {
      const sound = new Audio(recordStartSound);
      sound.volume = 0.5;
      sound.onended = () => {
        console.log("Son de d√©marrage jou√©");
        resolve();
      };
      sound.onerror = (e) => {
        console.warn("Erreur son de d√©marrage", e);
        resolve();
      };
      sound.play().catch(err => {
        console.warn("Play start sound catch:", err);
        resolve();
      });
    });
  }

  function analyzeAndPlay(blob) {
    const reader = new FileReader();
    reader.onload = e => {
      audioCtx.decodeAudioData(e.target.result).then(buffer => {
        analyzeRecordedAudio(buffer);
        // Play fallback MP3 (since no recognized text)
        chooseAndPlayMP3();
      }).catch(err => {
        console.error("Erreur d√©codage audio:", err);
        updateStatus("‚ö†Ô∏è Erreur d√©codage audio");
        logLine("‚ö†Ô∏è Erreur d√©codage audio : " + err.message);
        setTimeout(startProcess, 1000);
      });
    };
    reader.onerror = (e) => {
      console.error("Erreur lecture fichier audio:", e);
      updateStatus("‚ö†Ô∏è Erreur lecture fichier audio");
      logLine("‚ö†Ô∏è Erreur lecture fichier audio");
      setTimeout(startProcess, 1000);
    };
    reader.readAsArrayBuffer(blob);
  }

  function analyzeRecordedAudio(buffer) {
    try {
      const rawData = buffer.getChannelData(0);
      const sampleRate = buffer.sampleRate;

      let maxCorr = 0, bestLag = 0;
      for (let lag = 16; lag < 1000; lag++) {
        let corr = 0;
        for (let i = 0; i < rawData.length - lag; i++) {
          corr += rawData[i] * rawData[i + lag];
        }
        if (corr > maxCorr) {
          maxCorr = corr;
          bestLag = lag;
        }
      }
      userPitch = bestLag > 0 ? (sampleRate / bestLag) : 200;

      let sumSquares = 0;
      for (let i = 0; i < rawData.length; i++) {
        sumSquares += rawData[i] * rawData[i];
      }
      userVolume = Math.min(Math.sqrt(sumSquares / rawData.length), 1);

      if (userVolume < 0.02) {
        logLine("‚ö†Ô∏è Volume tr√®s faible d√©tect√©, v√©rifiez votre micro ou parlez plus fort.");
        updateStatus("‚ö†Ô∏è Volume micro faible");
      }

      let crossings = 0;
      for (let i = 1; i < rawData.length; i++) {
        if ((rawData[i - 1] < 0 && rawData[i] >= 0) || (rawData[i - 1] > 0 && rawData[i] <= 0)) {
          crossings++;
        }
      }
      userSpeed = crossings / rawData.length;

      console.log(`Analyse: pitch=${userPitch.toFixed(1)}, volume=${userVolume.toFixed(2)}, speed=${userSpeed.toFixed(3)}`);
      logLine(`üìä Analyse audio - pitch: ${userPitch.toFixed(1)}, volume: ${userVolume.toFixed(2)}, speed: ${userSpeed.toFixed(3)}`);
    } catch (err) {
      console.error("Erreur analyse audio:", err);
      logLine("‚ö†Ô∏è Erreur analyse audio : " + err.message);
    }
  }

  let recognition; // declared here for access outside

  function startRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      updateStatus("‚ö†Ô∏è Reconnaissance vocale non support√©e");
      logLine("‚ö†Ô∏è Votre navigateur ne supporte pas la reconnaissance vocale.");
      lastRecognizedText = "";
      return;
    }

    recognition = new SpeechRecognition();
    recognition.lang = "fr-FR";
    recognition.interimResults = false;
    recognition.continuous = false;

    recognition.onresult = e => {
      lastRecognizedText = e.results[0][0].transcript.toLowerCase();
      updateStatus(`‚úÖ Vous avez dit : "${lastRecognizedText}"`);
      logLine(`üó£Ô∏è Reconnu : "${lastRecognizedText}"`);
      // Play MP3 after recognition result
      chooseAndPlayMP3();
      // Stop media recorder immediately if recording
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    };

    recognition.onerror = e => {
      console.warn("Erreur reconnaissance:", e.error);
      updateStatus("‚ö†Ô∏è Erreur reconnaissance vocale: " + e.error);
      logLine("‚ö†Ô∏è Erreur reconnaissance: " + e.error);
      lastRecognizedText = "";
      // Stop media recorder on error as fallback
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    };

    recognition.onend = () => {
      console.log("Reconnaissance vocale termin√©e");
    };

    try {
      recognition.start();
      console.log("Reconnaissance vocale d√©marr√©e");
      setTimeout(() => {
        try { recognition.stop(); } catch {}
      }, RECORD_DURATION);
    } catch (err) {
      console.error("Erreur d√©marrage reconnaissance:", err);
      updateStatus("‚ö†Ô∏è Impossible de d√©marrer reconnaissance vocale");
      logLine("‚ö†Ô∏è Impossible de d√©marrer reconnaissance vocale");
    }
  }

  function chooseAndPlayMP3() {
    let foundKey = null;
    for (const key in keywordMap) {
      if (lastRecognizedText.includes(key)) {
        foundKey = key;
        break;
      }
    }

    let chosenPath;
    if (foundKey) {
      chosenPath = randomFromArray(keywordMap[foundKey]);
      logLine(`üéØ Mot-cl√© trouv√©: "${foundKey}" => ${chosenPath}`);
    } else {
      if (unusedFallbacks.length === 0) {
        unusedFallbacks = [...fallbackClips];
        logLine("‚ôªÔ∏è Tous fallback jou√©s, remise √† z√©ro.");
      }
      const index = Math.floor(Math.random() * unusedFallbacks.length);
      chosenPath = unusedFallbacks.splice(index, 1)[0];
      logLine(`‚ö†Ô∏è Pas de mot-cl√©, fallback choisi: ${chosenPath}`);
    }

    logTranscript(lastRecognizedText || "(rien)", chosenPath);
    playSoftOppositionMP3(chosenPath);
  }

  function playSoftOppositionMP3(path) {
    fetch(path)
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.arrayBuffer();
      })
      .then(data => audioCtx.decodeAudioData(data))
      .then(buffer => {
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;

        const basePitchFactor = 1 - (userPitch - 200) / 2000;
        const pitchRandomness = (Math.random() - 0.5) * 0.05;
        const pitchFactor = basePitchFactor + pitchRandomness;

        const baseSpeedFactor = 1 - userSpeed * 0.3;
        const speedRandomness = (Math.random() - 0.5) * 0.05;
        const speedFactor = baseSpeedFactor + speedRandomness;

        const finalRate = Math.min(Math.max(pitchFactor * speedFactor, 0.85), 1.15);
        source.playbackRate.value = finalRate;

        const gainNode = audioCtx.createGain();
        const volumeFactor = 0.7 + (userVolume * 0.6);
        gainNode.gain.value = volumeFactor;

        const panner = new StereoPannerNode(audioCtx, {
          pan: (Math.random() - 0.5) * 2
        });

        const filter = audioCtx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.value = 600 + (Math.random() * 800);
        filter.Q.value = 5;

        source.connect(filter).connect(panner).connect(gainNode).connect(audioCtx.destination);

        source.onended = () => {
          updateStatus("üîÑ Lecture termin√©e, red√©marrage...");
          logLine("üîÑ MP3 termin√©, red√©marrage processus...");
          setTimeout(startProcess, 500);
        };

        source.start();
        updateStatus(`‚ñ∂Ô∏è Lecture opposition ‚Äî rate: ${finalRate.toFixed(2)}, gain: ${volumeFactor.toFixed(2)}`);
        console.log(`Lecture: pitch=${userPitch.toFixed(1)}, volume=${userVolume.toFixed(2)}, speed=${userSpeed.toFixed(3)}, rate=${finalRate.toFixed(2)}, gain=${volumeFactor.toFixed(2)}`);
        logLine(`‚ñ∂Ô∏è Lecture MP3: ${path} (rate: ${finalRate.toFixed(2)}, gain: ${volumeFactor.toFixed(2)})`);
      })
      .catch(err => {
        console.error("Erreur lecture MP3:", err);
        updateStatus("‚ö†Ô∏è Erreur lecture MP3: " + err.message);
        logLine("‚ö†Ô∏è Erreur lecture MP3: " + err.message);
        setTimeout(startProcess, 1000);
      });
  }

  function randomFromArray(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function logTranscript(transcript, mp3) {
    const logBox = document.getElementById("log");
    const line = document.createElement("div");
    line.textContent = `üó£Ô∏è "${transcript}" ‚û°Ô∏è üéµ ${mp3}`;
    logBox.appendChild(line);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function logLine(text) {
    const logBox = document.getElementById("log");
    const line = document.createElement("div");
    line.textContent = text;
    logBox.appendChild(line);
    logBox.scrollTop = logBox.scrollHeight;
  }
</script>

</body>
</html>

