<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Mic Delay + CAT Response</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    button {
      font-size: 18px;
      padding: 10px 20px;
      margin-bottom: 20px;
    }
    input[type="range"] {
      width: 80%;
    }
    label {
      display: block;
      margin-top: 20px;
    }
  </style>
</head>
<body>

  <h1>Mic Delay + CAT Audio</h1>
  <button id="startBtn">Démarrer</button>

  <label for="micVol">Volume micro</label>
  <input type="range" id="micVol" min="0" max="1" step="0.01" value="0.5" />

  <label for="catVol">Volume CAT</label>
  <input type="range" id="catVol" min="0" max="1" step="0.01" value="0.5" />

  <script>
    const startBtn = document.getElementById('startBtn');
    const micVolSlider = document.getElementById('micVol');
    const catVolSlider = document.getElementById('catVol');

    let audioCtx, gainNodeMic, gainNodeCat;
    let catAudio = new Audio();
    catAudio.loop = true;
    let currentCat = "";

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognizer = new SpeechRecognition();
    recognizer.lang = 'fr-FR';
    recognizer.continuous = true;
    recognizer.interimResults = false;

    startBtn.onclick = async () => {
      startBtn.disabled = true;
      audioCtx = new AudioContext();

      // Micro avec délai
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const micSource = audioCtx.createMediaStreamSource(stream);

      const delay = audioCtx.createDelay(5.0);
      delay.delayTime.value = 3.0;

      gainNodeMic = audioCtx.createGain();
      gainNodeMic.gain.value = parseFloat(micVolSlider.value);

      micSource.connect(delay);
      delay.connect(gainNodeMic);
      gainNodeMic.connect(audioCtx.destination);

      // Cat audio routing
      gainNodeCat = audioCtx.createGain();
      gainNodeCat.gain.value = parseFloat(catVolSlider.value);

      const catSource = audioCtx.createMediaElementSource(catAudio);
      catSource.connect(gainNodeCat);
      gainNodeCat.connect(audioCtx.destination);

      micVolSlider.oninput = () => {
        gainNodeMic.gain.value = parseFloat(micVolSlider.value);
      };
      catVolSlider.oninput = () => {
        gainNodeCat.gain.value = parseFloat(catVolSlider.value);
      };

      // Lancer reconnaissance vocale
      recognizer.start();

      recognizer.onresult = (event) => {
        let transcript = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            transcript += event.results[i][0].transcript + " ";
          }
        }

        let words = transcript.trim().split(/\s+/).filter(w => w.length > 0);
        let count = words.length;

        let selectedCat = "";
        if (count === 0) selectedCat = "CAT1.mp3";
        else if (count <= 3) selectedCat = "CAT2.mp3";
        else selectedCat = "CAT3.mp3";

        if (selectedCat !== currentCat) {
          catAudio.pause();
          catAudio.src = selectedCat;
          catAudio.currentTime = 0;
          catAudio.play();
          currentCat = selectedCat;
        }
      };

      recognizer.onerror = (e) => {
        console.warn("Erreur reco:", e.error);
        recognizer.stop();
        setTimeout(() => recognizer.start(), 500);
      };
    };
  </script>

</body>
</html>
