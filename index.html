<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Mic + Keywords + Adaptation pitch/rythme</title>
<style>
  body { background: #111; color: white; font-family: sans-serif; text-align:center; padding:20px; }
  button { margin: 10px; padding: 15px 30px; font-size: 18px; cursor:pointer; }
  #status { margin-top: 20px; font-weight: bold; }
</style>
</head>
<body>

<h1>Analyse vocale et réponse adaptative</h1>

<button id="btnInvert">Mode Inversion (Pitch & Rythme opposés)</button>
<button id="btnSimilar">Mode Similarité (Pitch & Rythme similaires)</button>

<div id="status">Appuyez sur un bouton pour démarrer</div>

<script>
(async () => {
  // ----- CONFIG -----
  const LISTEN_DURATION_MS = 3000; // temps d'écoute, modifiable facilement
  const keywords = {
    merci: ['M/merci1.mp3', 'M/merci2.mp3'],
    oui: ['positifR1.mp3']
  };
  const fallbackRecordings = ['M/merci13.mp3'];

  // Pour éviter répétitions simples
  let lastPlayed = {merci: null, oui: null, fallback: null};

  // Etat mode : 'invert' ou 'similar'
  let mode = null;

  // Accès audio
  let audioContext = null;
  let mediaStream = null;
  let mediaStreamSource = null;
  let analyser = null;
  let dataArray = null;

  // Utilitaires
  function pickRandom(arr, last) {
    if (arr.length === 1) return arr[0];
    let filtered = arr.filter(x => x !== last);
    if (filtered.length === 0) filtered = arr;
    return filtered[Math.floor(Math.random() * filtered.length)];
  }

  // Analyse pitch (autocorrelation basique)
  function autoCorrelate(buffer, sampleRate) {
    // Source: https://github.com/cwilso/PitchDetect/blob/master/js/pitchdetect.js
    let SIZE = buffer.length;
    let MAX_SAMPLES = Math.floor(SIZE/2);
    let bestOffset = -1;
    let bestCorrelation = 0;
    let rms = 0;
    let foundGoodCorrelation = false;
    let correlations = new Array(MAX_SAMPLES);

    for (let i=0; i<SIZE; i++) {
      let val = buffer[i];
      rms += val*val;
    }
    rms = Math.sqrt(rms/SIZE);
    if (rms<0.01) return -1; // trop faible

    let lastCorrelation=1;
    for (let offset = 0; offset < MAX_SAMPLES; offset++) {
      let correlation = 0;
      for (let i=0; i<MAX_SAMPLES; i++) {
        correlation += Math.abs((buffer[i]) - (buffer[i+offset]));
      }
      correlation = 1 - (correlation/MAX_SAMPLES);
      correlations[offset] = correlation; 
      if ((correlation > 0.9) && (correlation > lastCorrelation)) {
        foundGoodCorrelation = true;
        if (correlation > bestCorrelation) {
          bestCorrelation = correlation;
          bestOffset = offset;
        }
      } else if (foundGoodCorrelation) {
        // found a good correlation & now decreasing
        let shift = (correlations[bestOffset+1] - correlations[bestOffset-1])/correlations[bestOffset];  
        return sampleRate/(bestOffset + 8*shift);
      }
      lastCorrelation = correlation;
    }
    if (bestCorrelation > 0.01) {
      return sampleRate/bestOffset;
    }
    return -1;
  }

  // Analyse rythme simplifiée (détection du tempo via énergie RMS) - approximation
  function estimateTempo(buffer, sampleRate) {
    // On calcule l'énergie RMS sur petits segments et on cherche des pics rythmiques
    // Ici on fera un truc simple: calcul RMS global (plus bas = plus lent)
    let rms = 0;
    for (let i=0; i<buffer.length; i++) rms += buffer[i]*buffer[i];
    rms = Math.sqrt(rms / buffer.length);
    return rms; // Plus élevé = plus énergique (potentiellement plus rapide)
  }

  // Jouer un mp3 avec pitch/rythme modifié (basique via playbackRate)
  function playAudio(url, pitch, tempo) {
    return new Promise(resolve => {
      const audio = new Audio(url);
      // Ajustement playbackRate pour tenter d'adapter pitch & rythme
      // pitch ~ playbackRate
      // tempo ~ playbackRate aussi (simplification)
      // On combine selon mode
      // playbackRate = tempo * pitch approx (dans [0.5 - 2])
      let rate = pitch * tempo;
      rate = Math.min(Math.max(rate, 0.5), 2);
      audio.playbackRate = rate;

      audio.onended = () => resolve();
      audio.play();
    });
  }

  // Process complet
  async function process() {
    if (!mediaStream) {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({audio:true});
      } catch(e) {
        statusDiv.textContent = "Erreur accès micro : " + e.message;
        return;
      }
    }
    if (!audioContext) audioContext = new AudioContext();
    if (!mediaStreamSource) mediaStreamSource = audioContext.createMediaStreamSource(mediaStream);
    if (!analyser) {
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      mediaStreamSource.connect(analyser);
      dataArray = new Float32Array(analyser.fftSize);
    }

    statusDiv.textContent = `Ecoute pendant ${LISTEN_DURATION_MS/1000} secondes...`;
    let chunks = [];
    let sampleRate = audioContext.sampleRate;

    // Collect audio data
    analyser.getFloatTimeDomainData(dataArray);

    // On attend la durée
    await new Promise(r => setTimeout(r, LISTEN_DURATION_MS));

    analyser.getFloatTimeDomainData(dataArray);

    // Analyse pitch & tempo
    let pitch = autoCorrelate(dataArray, sampleRate);
    if (pitch < 0) pitch = 440; // défaut A4 si non détecté
    let tempoEnergy = estimateTempo(dataArray, sampleRate);

    statusDiv.textContent = `Pitch estimé: ${pitch.toFixed(1)} Hz, énergie rythmique: ${tempoEnergy.toFixed(3)}`;

    // Reconnaissance keywords simple: On peut juste simuler via reconnaissance vocale
    // Ici, on utilise SpeechRecognition si disponible
    let recognizedWord = null;
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      let SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      let recog = new SpeechRecognition();
      recog.lang = 'fr-FR';
      recog.interimResults = false;
      recog.maxAlternatives = 1;

      recog.start();
      recognizedWord = await new Promise(res => {
        recog.onresult = (event) => {
          let transcript = event.results[0][0].transcript.toLowerCase();
          // Vérifie si un keyword est présent dans le texte
          for (const kw of Object.keys(keywords)) {
            if (transcript.includes(kw)) {
              res(kw);
              recog.stop();
              return;
            }
          }
          res(null);
          recog.stop();
        };
        recog.onerror = () => res(null);
        setTimeout(() => { recog.stop(); res(null); }, LISTEN_DURATION_MS);
      });
    }

    // Choix de la piste à jouer
    let chosenUrl;
    if (recognizedWord && keywords[recognizedWord]) {
      chosenUrl = pickRandom(keywords[recognizedWord], lastPlayed[recognizedWord]);
      lastPlayed[recognizedWord] = chosenUrl;
    } else {
      chosenUrl = pickRandom(fallbackRecordings, lastPlayed.fallback);
      lastPlayed.fallback = chosenUrl;
    }

    // Calcule pitch et tempo de base pour inverser ou similaire
    // Pour inversion on prend pitch inverse (A4=440 => 1/440 normalisé), tempo inverse
    // Simplification : 
    // Normalisation pitch entre 0.5 et 2 pour playbackRate
    let basePitchRate = Math.min(Math.max(pitch/440, 0.5), 2);
    let baseTempoRate = Math.min(Math.max(tempoEnergy*10, 0.5), 2); // facteur arbitraire

    let pitchRate, tempoRate;
    if (mode === 'invert') {
      pitchRate = 1 / basePitchRate;
      tempoRate = 1 / baseTempoRate;
    } else {
      pitchRate = basePitchRate;
      tempoRate = baseTempoRate;
    }

    statusDiv.textContent += `\nLecture : ${chosenUrl} (pitchRate: ${pitchRate.toFixed(2)}, tempoRate: ${tempoRate.toFixed(2)})`;

    await playAudio(chosenUrl, pitchRate, tempoRate);

    // Recommencer en boucle si mode activé
    if (mode !== null) process();
  }

  // Gestion boutons
  const btnInvert = document.getElementById('btnInvert');
  const btnSimilar = document.getElementById('btnSimilar');
  const statusDiv = document.getElementById('status');

  btnInvert.onclick = () => {
    if (mode === 'invert') return; // déjà en mode invert
    mode = 'invert';
    statusDiv.textContent = "Mode INVERSION activé, démarrage...";
    process();
  };
  btnSimilar.onclick = () => {
    if (mode === 'similar') return; // déjà en mode similar
    mode = 'similar';
    statusDiv.textContent = "Mode SIMILARITE activé, démarrage...";
    process();
  };
})();
</script>

</body>
</html>

